<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="strafer-liberator">
    <title>Arhitectura</title>
    <topic id="launchers">
        <title>Launchers</title>
        <body>
            <p>Fiecare launcher determina rezolutia si setarile necesare sistemului pe care ruleaza,
                apoi instantiaza game class-ul Strafer din core</p>
            <bodydiv>
                <p>Strafer- Game class-ul in care se regaseste rendering loop-ul si unde sunt
                    declarate constantele globale si obiecte statice:</p>
                <ul id="ul_esg_gy4_fyb">
                    <li>WORLD_WIDTH, WORLD_HEIGHT </li>
                    <li>aspectRatio</li>
                    <li>SCALE_FACTOR unitatea de masura principala(1 metru=32 pixeli)</li>
                    <li>assetManager incarca si returneaza asseturi recursiv din folderul assets in
                        timpul fazei de loading</li>
                    <li>i18n traduce stringuri in functie de limba setata</li>
                    <li>spriteBatch se ocupa cu rendering-ul sprite-urilor pe ecran</li>
                    <li>tiledMapRenderer un OrthogonalTiledMapRenderer modificat pentru a evita
                        probleme de texture bleeding, se ocupa de rendering pentru fisiere tmx,
                        tiled maps</li>
                    <li>inputManager decide ce tip de platforma si periferice sunt disponibile si
                        seteaza ce tip de InputProcessor este
                        necesar(Keyboard,Controller,Touchscreen). Input-ul nu este hardcodat, ci se
                        incarca din fisierul preferences, adica fiecare tasta poate fi reconfigurata
                        de user. libGDX permite de asemenea utilizarea acestor tipuri de input
                        interschimbabil intre platforme(Controller, Keyboard pe mobile, touch pe
                        desktop etc)</li>
                    <li>worldCamera este camera care se plimba pe harta dupa entitati</li>
                    <li>extendViewport este folosit de worldCamera pentru a determina portiunea
                        vizibla din ecran, acesta se adapteaza pentru orice resize al windowului si
                        orice aspect ratio</li>
                    <li>uiManager un scene2d stage, contine toate meniurile si componentele de user
                        interface</li>
                    <li>uiCamera este o alta camera cu un screenViewport care separa ui-ul de
                        gameworld</li>
                    <li>loadingScreen</li>
                    <li>settingsScreen</li>
                    <li>titleScreen</li>
                </ul>
                <p>gameScreen ecranul in care se petrece gameplay loop-ul. Aici este instantiat pe
                    uiManager un HUD, adica user interface-ul prezent in timpul jocului(healthbar si
                    input pentru mobile). Pe gameScreen se instantiaza un GameWorld, container-ul
                    pentru toata lumea jocului.</p>
                <ul id="ul_fsg_gy4_fyb">
                    <li>rayHandler se va ocupa de iluminarea obiectelor din physics engine</li>
                    <li>box2dWorld este container-ul pentru physics engine (box2d) Pentru a crea
                        Body-uri, Sensor-uri si Fixture-uri folosim clasa Box2dFactory</li>
                    <li>tiledMap este harta propriu-zisa a jocului din care se incarca automat
                        checkpoint-uri si pereti</li>
                    <li>FIXED_TIME_STEP constanta folosita pentru a da update in physics engine la
                        un interval constant de timp, lucru ce separa frame rate-ul de coliziuni si
                        movement</li>
                    <li>entityEngine este un PooledEngine din framework-ul Ashley. Acesta este un
                        entity-component system ce permite management-ul entitatilor care sunt
                        formate prin compunere de componente, asupra carora actioneaza diferite
                        system-uri .Un system itereaza prin orice entity care contine compinentele
                        specificate pe constructor si proceseaza datele acestuia. Astfel creste
                        valoarea de reutilizare a compinentelor, evitand inheritance-ul. Acesta are
                        un pattern de factory, adica poate returna prin metode Entity-uri, spre
                        exemplu player-ul</li>
                </ul>
                <p>Player-ul are mai multe componente:</p>
                <ul id="ul_gsg_gy4_fyb">
                    <li>PlayerComponent folosit pentru controlarea playerului, acesta are un sensor
                        fixture pe body folosit pentru a determina alte entity-uri din
                        proximitate</li>
                    <li>EntityTypeComponent indica ce tip de entity este playerul si in ce state se
                        afla(idle,hit, walk etc)</li>
                    <li>PositionComponent pozitia in lume</li>
                    <li>MovementComponent directiile de deplasare active, viteza si forta de
                        dash</li>
                    <li>SpriteComponent imaginea entity-ului si dimensiunile acesteia</li>
                    <li>AnimationComponent un Animation&lt;Sprite> si un timer intern folosit pentru
                        actualizarea animatiei</li>
                    <li>Box2dComponent indica engine-ului ca entity-ul ia parte in coliziuni.
                        Body-ul este creat dupa dimensiunile sprite-ului avand doua Fixture-uri:
                        fingerprint-ul(partea solida a corpului) si hurtbox-ul(folosit pentru
                        interactiunile de combat cu hitboxuri)</li>
                    <li>HealthConponent entity-ul ia parte in combat si poate primi damage.</li>
                    <li>CameraComponent camera poate focusa entity-ul</li>
                </ul>
                <p>alte entity-uri pot avea:</p>
                <ul id="ul_hsg_gy4_fyb">
                    <li>DetectorComponent detecteaza proximitatea cu playerul</li>
                    <li>CheckpointComponent primeste un checkpoint action si este focusat automat de
                        camera in zonele hartii care sunt points of interest</li>
                    <li>AttackComponent are un hitbox si alte caracteristici ale unui atac precum
                        damage tip de atac etc</li>
                </ul>
                <p>System-uri</p>
                <ul id="ul_isg_gy4_fyb">
                    <li>AnimationSystem se foloseste de counterele din AnimationComponent si schimba
                        SpriteComponent-ul cu frame-ul curent. Animatiile sunt incarcate din
                        AnimationProvider pe baza EntityType-ului si al EntityState-ului. Animatiile
                        sunt salave in spritesheet-uri si decodate cu un fisier atlas in care sunt
                        salvate informatii despre toate frame-urile animatiilor. Astfel este necesar
                        un singur png si un fisier atlas pentru toate animatiile.</li>
                    <li>CheckpointSystem executa actiunile din checkpointuri cand sunt atinse</li>
                    <li>RenderingSystem foloseste spriteBatch-ul si randeaza Sprite-urile la
                        pozitiile entity-urilor dupa ce compara pozitia lor pe axa Y, astfel incat
                        sprite-urile sa para ca pot fi unul in spatele celuilalt.</li>
                    <li>HudSystem actualizeaza hud-ul cu informatii din player</li>
                    <li>CameraSystem decide unde este focusata camera. Daca player-ul este in
                        proximitatea unui grup de inamici camera focuseaza in mijlocul grupului.
                        Daca exista un checkpoint in proximitate, acesta va fi focusat. Daca
                        playerul nu are entity-uri cu CameraComponent in proximitate este focusat
                        singur.</li>
                    <li>HealthSystem verifica daca un hurtbox a primit damage si actualizeaza
                        nivelul de health</li>
                    <li>CombatSystem aplica efecte de knockback daca un entity a fost lovit</li>
                </ul>
                <p>FilteredContactListener este un listener adaugat la box2dWorld care filtreaza
                    coliziunile astfel incat sa determine cand s-a realizat un contact intre
                    hitbox-uri/hurtbox-uri sau intre sensorul playerului si un detector</p>
            </bodydiv>
        </body>
    </topic>
</topic>
